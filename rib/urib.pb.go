// Code generated by protoc-gen-go. DO NOT EDIT.
// source: urib.proto

package urib

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// URIB event type
type UribEventType int32

const (
	UribEventType_URIB_EVENT_TYPE_NO_EVENT      UribEventType = 0
	UribEventType_URIB_EVENT_TYPE_ADD           UribEventType = 1
	UribEventType_URIB_EVENT_TYPE_DELETE        UribEventType = 2
	UribEventType_URIB_EVENT_TYPE_UPDATE        UribEventType = 3
	UribEventType_URIB_EVENT_TYPE_DOWNLOAD      UribEventType = 4
	UribEventType_URIB_EVENT_TYPE_DOWNLOAD_DONE UribEventType = 5
)

var UribEventType_name = map[int32]string{
	0: "URIB_EVENT_TYPE_NO_EVENT",
	1: "URIB_EVENT_TYPE_ADD",
	2: "URIB_EVENT_TYPE_DELETE",
	3: "URIB_EVENT_TYPE_UPDATE",
	4: "URIB_EVENT_TYPE_DOWNLOAD",
	5: "URIB_EVENT_TYPE_DOWNLOAD_DONE",
}

var UribEventType_value = map[string]int32{
	"URIB_EVENT_TYPE_NO_EVENT":      0,
	"URIB_EVENT_TYPE_ADD":           1,
	"URIB_EVENT_TYPE_DELETE":        2,
	"URIB_EVENT_TYPE_UPDATE":        3,
	"URIB_EVENT_TYPE_DOWNLOAD":      4,
	"URIB_EVENT_TYPE_DOWNLOAD_DONE": 5,
}

func (x UribEventType) String() string {
	return proto.EnumName(UribEventType_name, int32(x))
}

func (UribEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e264597aff88d0fb, []int{0}
}

// URIB encap type
type EncapType int32

const (
	EncapType_ENCAP_TYPE_NONE  EncapType = 0
	EncapType_ENCAP_TYPE_VXLAN EncapType = 1
)

var EncapType_name = map[int32]string{
	0: "ENCAP_TYPE_NONE",
	1: "ENCAP_TYPE_VXLAN",
}

var EncapType_value = map[string]int32{
	"ENCAP_TYPE_NONE":  0,
	"ENCAP_TYPE_VXLAN": 1,
}

func (x EncapType) String() string {
	return proto.EnumName(EncapType_name, int32(x))
}

func (EncapType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e264597aff88d0fb, []int{1}
}

// URIB next hop type
type NhType int32

const (
	NhType_NH_TYPE_NONE      NhType = 0
	NhType_NH_TYPE_ATTACHED  NhType = 1
	NhType_NH_TYPE_LOCAL     NhType = 2
	NhType_NH_TYPE_DIRECT    NhType = 3
	NhType_NH_TYPE_RECURSIVE NhType = 4
	NhType_NH_TYPE_BACKUP    NhType = 5
	NhType_NH_TYPE_DROP      NhType = 6
	NhType_NH_TYPE_DISCARD   NhType = 7
)

var NhType_name = map[int32]string{
	0: "NH_TYPE_NONE",
	1: "NH_TYPE_ATTACHED",
	2: "NH_TYPE_LOCAL",
	3: "NH_TYPE_DIRECT",
	4: "NH_TYPE_RECURSIVE",
	5: "NH_TYPE_BACKUP",
	6: "NH_TYPE_DROP",
	7: "NH_TYPE_DISCARD",
}

var NhType_value = map[string]int32{
	"NH_TYPE_NONE":      0,
	"NH_TYPE_ATTACHED":  1,
	"NH_TYPE_LOCAL":     2,
	"NH_TYPE_DIRECT":    3,
	"NH_TYPE_RECURSIVE": 4,
	"NH_TYPE_BACKUP":    5,
	"NH_TYPE_DROP":      6,
	"NH_TYPE_DISCARD":   7,
}

func (x NhType) String() string {
	return proto.EnumName(NhType_name, int32(x))
}

func (NhType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e264597aff88d0fb, []int{2}
}

// Next hop
type NxL3NextHopProto struct {
	// Address of Next hop
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// Outgoing interface for the next hop
	OutInterface string `protobuf:"bytes,2,opt,name=out_interface,json=outInterface,proto3" json:"out_interface,omitempty"`
	// Vrf name for the next hop
	VrfName string `protobuf:"bytes,3,opt,name=vrf_name,json=vrfName,proto3" json:"vrf_name,omitempty"`
	// Owner of the next hop
	Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
	// Preference for the next hop
	Preference uint32 `protobuf:"varint,5,opt,name=preference,proto3" json:"preference,omitempty"`
	// Metric for the next hop
	Metric uint32 `protobuf:"varint,6,opt,name=metric,proto3" json:"metric,omitempty"`
	// Tag for the next hop
	Tag uint32 `protobuf:"varint,7,opt,name=tag,proto3" json:"tag,omitempty"`
	// segment id for the next hop
	SegmentId uint32 `protobuf:"varint,8,opt,name=segment_id,json=segmentId,proto3" json:"segment_id,omitempty"`
	// tunnel id for the next hop
	TunnelId uint32 `protobuf:"varint,9,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"`
	// encap type for the next hop
	EncapType EncapType `protobuf:"varint,10,opt,name=encap_type,json=encapType,proto3,enum=EncapType" json:"encap_type,omitempty"`
	// Bitwise-OR of Flags for NhType.
	NhTypeFlags          uint32   `protobuf:"varint,11,opt,name=nh_type_flags,json=nhTypeFlags,proto3" json:"nh_type_flags,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NxL3NextHopProto) Reset()         { *m = NxL3NextHopProto{} }
func (m *NxL3NextHopProto) String() string { return proto.CompactTextString(m) }
func (*NxL3NextHopProto) ProtoMessage()    {}
func (*NxL3NextHopProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_e264597aff88d0fb, []int{0}
}

func (m *NxL3NextHopProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NxL3NextHopProto.Unmarshal(m, b)
}
func (m *NxL3NextHopProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NxL3NextHopProto.Marshal(b, m, deterministic)
}
func (m *NxL3NextHopProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NxL3NextHopProto.Merge(m, src)
}
func (m *NxL3NextHopProto) XXX_Size() int {
	return xxx_messageInfo_NxL3NextHopProto.Size(m)
}
func (m *NxL3NextHopProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NxL3NextHopProto.DiscardUnknown(m)
}

var xxx_messageInfo_NxL3NextHopProto proto.InternalMessageInfo

func (m *NxL3NextHopProto) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NxL3NextHopProto) GetOutInterface() string {
	if m != nil {
		return m.OutInterface
	}
	return ""
}

func (m *NxL3NextHopProto) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *NxL3NextHopProto) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *NxL3NextHopProto) GetPreference() uint32 {
	if m != nil {
		return m.Preference
	}
	return 0
}

func (m *NxL3NextHopProto) GetMetric() uint32 {
	if m != nil {
		return m.Metric
	}
	return 0
}

func (m *NxL3NextHopProto) GetTag() uint32 {
	if m != nil {
		return m.Tag
	}
	return 0
}

func (m *NxL3NextHopProto) GetSegmentId() uint32 {
	if m != nil {
		return m.SegmentId
	}
	return 0
}

func (m *NxL3NextHopProto) GetTunnelId() uint32 {
	if m != nil {
		return m.TunnelId
	}
	return 0
}

func (m *NxL3NextHopProto) GetEncapType() EncapType {
	if m != nil {
		return m.EncapType
	}
	return EncapType_ENCAP_TYPE_NONE
}

func (m *NxL3NextHopProto) GetNhTypeFlags() uint32 {
	if m != nil {
		return m.NhTypeFlags
	}
	return 0
}

// L3 route
type NxL3RouteProto struct {
	// Vrf name of the l3 route
	VrfName string `protobuf:"bytes,1,opt,name=vrf_name,json=vrfName,proto3" json:"vrf_name,omitempty"`
	// l3 route prefix address
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	// Mask length for the l3 route
	MaskLen uint32 `protobuf:"varint,3,opt,name=mask_len,json=maskLen,proto3" json:"mask_len,omitempty"`
	// Number of next hops for the l3 route
	L3NextHopCount uint32 `protobuf:"varint,4,opt,name=l3_next_hop_count,json=l3NextHopCount,proto3" json:"l3_next_hop_count,omitempty"`
	// Event type
	EventType UribEventType `protobuf:"varint,5,opt,name=event_type,json=eventType,proto3,enum=UribEventType" json:"event_type,omitempty"`
	// Next hops
	NextHop              []*NxL3NextHopProto `protobuf:"bytes,6,rep,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NxL3RouteProto) Reset()         { *m = NxL3RouteProto{} }
func (m *NxL3RouteProto) String() string { return proto.CompactTextString(m) }
func (*NxL3RouteProto) ProtoMessage()    {}
func (*NxL3RouteProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_e264597aff88d0fb, []int{1}
}

func (m *NxL3RouteProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NxL3RouteProto.Unmarshal(m, b)
}
func (m *NxL3RouteProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NxL3RouteProto.Marshal(b, m, deterministic)
}
func (m *NxL3RouteProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NxL3RouteProto.Merge(m, src)
}
func (m *NxL3RouteProto) XXX_Size() int {
	return xxx_messageInfo_NxL3RouteProto.Size(m)
}
func (m *NxL3RouteProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NxL3RouteProto.DiscardUnknown(m)
}

var xxx_messageInfo_NxL3RouteProto proto.InternalMessageInfo

func (m *NxL3RouteProto) GetVrfName() string {
	if m != nil {
		return m.VrfName
	}
	return ""
}

func (m *NxL3RouteProto) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *NxL3RouteProto) GetMaskLen() uint32 {
	if m != nil {
		return m.MaskLen
	}
	return 0
}

func (m *NxL3RouteProto) GetL3NextHopCount() uint32 {
	if m != nil {
		return m.L3NextHopCount
	}
	return 0
}

func (m *NxL3RouteProto) GetEventType() UribEventType {
	if m != nil {
		return m.EventType
	}
	return UribEventType_URIB_EVENT_TYPE_NO_EVENT
}

func (m *NxL3RouteProto) GetNextHop() []*NxL3NextHopProto {
	if m != nil {
		return m.NextHop
	}
	return nil
}

func init() {
	proto.RegisterEnum("UribEventType", UribEventType_name, UribEventType_value)
	proto.RegisterEnum("EncapType", EncapType_name, EncapType_value)
	proto.RegisterEnum("NhType", NhType_name, NhType_value)
	proto.RegisterType((*NxL3NextHopProto)(nil), "NxL3NextHopProto")
	proto.RegisterType((*NxL3RouteProto)(nil), "NxL3RouteProto")
}

func init() { proto.RegisterFile("urib.proto", fileDescriptor_e264597aff88d0fb) }

var fileDescriptor_e264597aff88d0fb = []byte{
	// 602 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x93, 0xdd, 0x4e, 0xdb, 0x3e,
	0x18, 0xc6, 0x49, 0xbf, 0xf3, 0x42, 0xfa, 0x77, 0x0d, 0x7f, 0x66, 0xb6, 0x31, 0x75, 0xec, 0xa4,
	0xa0, 0xad, 0x07, 0x20, 0xed, 0x3c, 0x24, 0x9e, 0xa8, 0x16, 0xa5, 0x95, 0x49, 0xd9, 0xc7, 0x89,
	0x15, 0x5a, 0x17, 0xaa, 0xb5, 0x4e, 0x94, 0xba, 0x0c, 0x2e, 0x69, 0x57, 0xb1, 0xcb, 0xd8, 0x2d,
	0xec, 0x12, 0x76, 0x38, 0xd9, 0x25, 0x5b, 0xa8, 0xd8, 0x99, 0x9f, 0xdf, 0x63, 0xbf, 0xce, 0xfb,
	0xbc, 0x31, 0xc0, 0x32, 0x9b, 0x5e, 0x76, 0xd3, 0x2c, 0x51, 0xc9, 0xc1, 0x8f, 0x12, 0xa0, 0xf0,
	0x36, 0x38, 0x09, 0xc5, 0xad, 0x3a, 0x4b, 0xd2, 0x81, 0x86, 0x98, 0x40, 0x3d, 0x1e, 0x8f, 0x33,
	0xb1, 0x58, 0x10, 0xab, 0x6d, 0x75, 0x6c, 0x96, 0x4b, 0xfc, 0x0a, 0x9c, 0x64, 0xa9, 0xf8, 0x54,
	0x2a, 0x91, 0x4d, 0xe2, 0x91, 0x20, 0x25, 0xe3, 0x6f, 0x25, 0x4b, 0xd5, 0xcb, 0x19, 0xde, 0x83,
	0xc6, 0x4d, 0x36, 0xe1, 0x32, 0x9e, 0x0b, 0x52, 0x5e, 0x9d, 0xbf, 0xc9, 0x26, 0x61, 0x3c, 0x17,
	0x78, 0x07, 0xaa, 0xc9, 0x57, 0x29, 0x32, 0x52, 0x31, 0x7c, 0x25, 0xf0, 0x0b, 0x80, 0x34, 0x13,
	0x13, 0x91, 0x09, 0x39, 0x12, 0xa4, 0xda, 0xb6, 0x3a, 0x0e, 0x2b, 0x10, 0xbc, 0x0b, 0xb5, 0xb9,
	0x50, 0xd9, 0x74, 0x44, 0x6a, 0xc6, 0xbb, 0x57, 0x18, 0x41, 0x59, 0xc5, 0x57, 0xa4, 0x6e, 0xa0,
	0x5e, 0xe2, 0x7d, 0x80, 0x85, 0xb8, 0x9a, 0x0b, 0xa9, 0xf8, 0x74, 0x4c, 0x1a, 0xc6, 0xb0, 0xef,
	0x49, 0x6f, 0x8c, 0x9f, 0x81, 0xad, 0x96, 0x52, 0x8a, 0x99, 0x76, 0x6d, 0xe3, 0x36, 0x56, 0xa0,
	0x37, 0xc6, 0x87, 0x00, 0x42, 0x8e, 0xe2, 0x94, 0xab, 0xbb, 0x54, 0x10, 0x68, 0x5b, 0x9d, 0xe6,
	0x31, 0x74, 0xa9, 0x46, 0xd1, 0x5d, 0x2a, 0x98, 0x2d, 0xf2, 0x25, 0x3e, 0x00, 0x47, 0x5e, 0x9b,
	0x7d, 0x7c, 0x32, 0x8b, 0xaf, 0x16, 0x64, 0xd3, 0xd4, 0xda, 0x94, 0xd7, 0xda, 0x7e, 0xa7, 0xd1,
	0xc1, 0x4f, 0x0b, 0x9a, 0x3a, 0x59, 0x96, 0x2c, 0x95, 0x58, 0xe5, 0x5a, 0x0c, 0xc6, 0x7a, 0x18,
	0x4c, 0x21, 0xf2, 0xd2, 0xc3, 0xc8, 0xf7, 0xa0, 0x31, 0x8f, 0x17, 0x5f, 0xf8, 0x4c, 0x48, 0x93,
	0xa6, 0xc3, 0xea, 0x5a, 0x07, 0x42, 0xe2, 0x43, 0x68, 0xcd, 0x4e, 0xb8, 0x14, 0xb7, 0x8a, 0x5f,
	0x27, 0x29, 0x1f, 0x25, 0x4b, 0xa9, 0x4c, 0xb2, 0x0e, 0x6b, 0xce, 0xf2, 0x91, 0x7a, 0x9a, 0xe2,
	0x37, 0x00, 0xe2, 0x46, 0xc7, 0x62, 0x9a, 0xab, 0x9a, 0xe6, 0x9a, 0xdd, 0x61, 0x36, 0xbd, 0xa4,
	0x1a, 0xdf, 0x37, 0x98, 0x2f, 0xf1, 0x6b, 0x68, 0xe4, 0x65, 0x49, 0xad, 0x5d, 0xee, 0x6c, 0x1e,
	0xb7, 0xba, 0xeb, 0xbf, 0x09, 0xab, 0xcb, 0x95, 0x3a, 0xfa, 0x6e, 0x81, 0xf3, 0xa0, 0x14, 0x7e,
	0x0e, 0x64, 0xc8, 0x7a, 0xa7, 0x9c, 0x5e, 0xd0, 0x30, 0xe2, 0xd1, 0xa7, 0x01, 0xe5, 0x61, 0x7f,
	0xa5, 0xd0, 0x06, 0x7e, 0x02, 0xdb, 0xeb, 0xae, 0xeb, 0xfb, 0xc8, 0xc2, 0x4f, 0x61, 0x77, 0xdd,
	0xf0, 0x69, 0x40, 0x23, 0x8a, 0x4a, 0x8f, 0x79, 0xc3, 0x81, 0xef, 0x46, 0x14, 0x95, 0x1f, 0xbb,
	0xce, 0xef, 0x7f, 0x08, 0x83, 0xbe, 0xeb, 0xa3, 0x0a, 0x7e, 0x09, 0xfb, 0xff, 0x72, 0xb9, 0xdf,
	0x0f, 0x29, 0xaa, 0x1e, 0xbd, 0x05, 0xfb, 0xcf, 0xa0, 0xf1, 0x36, 0xfc, 0x47, 0x43, 0xcf, 0x1d,
	0xe4, 0xdf, 0x1d, 0x52, 0xb4, 0x81, 0x77, 0x00, 0x15, 0xe0, 0xc5, 0xc7, 0xc0, 0x0d, 0x91, 0x75,
	0xf4, 0xcd, 0x82, 0x5a, 0x68, 0x86, 0x8e, 0x11, 0x6c, 0x85, 0x67, 0xeb, 0x47, 0x72, 0xe2, 0x46,
	0x91, 0xeb, 0x9d, 0x51, 0xdd, 0x63, 0x0b, 0x9c, 0x9c, 0x06, 0x7d, 0xcf, 0x0d, 0x50, 0x09, 0x63,
	0x68, 0xe6, 0xc8, 0xef, 0x31, 0xea, 0x45, 0xa8, 0x8c, 0xff, 0x87, 0x56, 0xce, 0x18, 0xf5, 0x86,
	0xec, 0xbc, 0x77, 0x41, 0x51, 0xa5, 0xb8, 0xf5, 0xd4, 0xf5, 0xde, 0x0f, 0x07, 0xa8, 0x5a, 0xbc,
	0xd9, 0x67, 0xfd, 0x01, 0xaa, 0xe9, 0x0e, 0xfe, 0x16, 0x3c, 0xf7, 0x5c, 0xe6, 0xa3, 0xfa, 0xa9,
	0xfd, 0xb9, 0xa2, 0x1f, 0xfe, 0x2f, 0xcb, 0xba, 0xac, 0x99, 0xc7, 0x7f, 0xf2, 0x3b, 0x00, 0x00,
	0xff, 0xff, 0x44, 0x95, 0xf1, 0xa6, 0x0a, 0x04, 0x00, 0x00,
}
